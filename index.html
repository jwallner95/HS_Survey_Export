<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Survey123 Export Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- SheetJS (Excel) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

<!-- jsPDF (PDF) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 1.5rem;
    }
    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
    }
    .card {
      border: 1px solid #ddd;
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      max-width: 900px;
    }
    .status {
      margin: 0.5rem 0 1rem;
      font-size: 0.9rem;
      color: #555;
    }
    .field-list {
      max-height: 250px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 0.5rem;
      padding: 0.5rem 0.75rem;
      margin-bottom: 1rem;
    }
    .field-list label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
    }
    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    button {
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      border: 1px solid #ccc;
      background: #f5f5f5;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button.primary {
      background: #007ac2;
      border-color: #007ac2;
      color: white;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .small {
      font-size: 0.8rem;
      color: #777;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Survey123 Data Export</h1>
    <div class="status" id="status">Initialising…</div>

    <!-- Sign-in section -->
    <div id="auth-section">
      <button id="signin-btn" class="primary">Sign in with ArcGIS Online</button>
      <p class="small">You’ll be redirected to ArcGIS Online to sign in, then returned here.</p>
    </div>

    <!-- Export section -->
    <div id="export-section" style="display:none;">
      <p><strong>Filter records to export:</strong></p>

      <label class="small">
        Filter by
        <span id="filter-field-label">(loading…)</span>:
        <select id="filter-select">
          <option value="__ALL__">Loading…</option>
        </select>
      </label>

      <p class="small" style="margin-top:0.5rem;">
        The export will include all non-system fields. Photo attachments will be included as URLs where available.
      </p>

      <div class="buttons" style="margin-top:0.75rem;">
        <button id="export-excel-btn" class="primary">Export to Excel (.xlsx)</button>
        <button id="export-pdf-btn">Export to PDF</button>
      </div>
    </div>
  </div>

  <script>
    // ------------------- CONFIG -------------------
    const CONFIG = {
      portalUrl: "https://cwa-scotland.maps.arcgis.com/",   // or your-org.maps.arcgis.com
      clientId:  "x6jTMM7Vlfm0gIUP",      // paste your real client ID here

      // IMPORTANT: this must match the URL you actually use to access the page,
      // and it must be in the AGOL OAuth app's redirect URI list.
      redirectUri: "https://jwallner95.github.io/HS_Survey_Export/",

      // Your Survey123 feature layer (0 = main layer)
      featureLayerUrl: "https://services-eu1.arcgis.com/bSzjBBo9coEnBAyV/arcgis/rest/services/service_39d7614810094160acf4dd46d553e37c/FeatureServer/0",

      maxRecordCountForExport: 5000,

 // Single attribute field to filter by (dropdown)
      filterField: {
        name:  "PullUsername",          // <-- EXACT field name from REST (e.g. 'Status', 'SiteCode', etc.)
        alias: "Username"           // label shown in UI
      }
    };
    let accessToken = null;
    let username = null;

    let layerInfo = null;
    let allExportFields = [];     // [{name, alias, isAttachment}]
    let objectIdFieldName = null; // e.g. "OBJECTID"
    let filterFieldType = null;   // to know if we need quotes in WHERE

    const statusEl      = document.getElementById("status");
    const authSection   = document.getElementById("auth-section");
    const exportSection = document.getElementById("export-section");

    const signinBtn     = document.getElementById("signin-btn");
    const exportExcelBtn= document.getElementById("export-excel-btn");
    const exportPdfBtn  = document.getElementById("export-pdf-btn");

    const filterFieldLabelEl = document.getElementById("filter-field-label");
    const filterSelectEl     = document.getElementById("filter-select");

    // ---------- OAUTH HELPERS ----------

    function getTokenFromHash() {
      if (!window.location.hash) return null;
      const hash = window.location.hash.substring(1);
      const params = new URLSearchParams(hash);
      const token = params.get("access_token");
      const user = params.get("username");
      if (token) {
        history.replaceState(null, "", window.location.pathname + window.location.search);
        return { token, user };
      }
      return null;
    }

    function startOAuth() {
      const authUrl = CONFIG.portalUrl
        + "/sharing/rest/oauth2/authorize"
        + "?client_id=" + encodeURIComponent(CONFIG.clientId)
        + "&response_type=token"
        + "&redirect_uri=" + encodeURIComponent(CONFIG.redirectUri)
        + "&expiration=120"
        + "&state=survey_export";
      window.location.href = authUrl;
    }

    async function getUserInfo() {
      const url = CONFIG.portalUrl
        + "/sharing/rest/community/self?f=json&token="
        + encodeURIComponent(accessToken);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Failed to get user info");
      const data = await resp.json();
      if (data.error) throw new Error(data.error.message || "Error fetching user info");
      return data;
    }

    // ---------- FEATURE LAYER HELPERS ----------

    async function fetchLayerMetadata() {
      const url = CONFIG.featureLayerUrl
        + "?f=json&token=" + encodeURIComponent(accessToken);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Failed to load layer metadata");
      const data = await resp.json();
      if (data.error) throw new Error(data.error.message || "Layer metadata error");
      return data;
    }

    function buildFieldLists() {
      const fields = layerInfo.fields || [];
      const excludeNames = ["Shape", "SHAPE", "shape", "GlobalID", "globalid"];
      const exportFields = [];

      // Identify OID field
      objectIdFieldName = layerInfo.objectIdField
        || (fields.find(f => f.type === "esriFieldTypeOID")?.name || "OBJECTID");

      fields.forEach(f => {
        if (f.type === "esriFieldTypeGeometry") return;
        if (excludeNames.includes(f.name)) return;
        // we still want OBJECTID, it's useful
        exportFields.push({
          name: f.name,
          alias: f.alias || f.name,
          isAttachment: false
        });

        if (f.name === CONFIG.filterField.name) {
          filterFieldType = f.type; // e.g. esriFieldTypeString
        }
      });

      // Synthetic "PhotoURLs" column if attachments enabled
      if (layerInfo.hasAttachments) {
        exportFields.push({
          name: "_PhotoURLs",
          alias: "Photo URLs",
          isAttachment: true
        });
      }

      allExportFields = exportFields;
    }

    async function fetchFilterOptions() {
      statusEl.textContent = "Loading filter values…";

      const url = CONFIG.featureLayerUrl + "/query";
      const params = new URLSearchParams({
        f: "json",
        where: "1=1",
        outFields: CONFIG.filterField.name,
        returnDistinctValues: "true",
        returnGeometry: "false",
        orderByFields: CONFIG.filterField.name,
        token: accessToken
      });

      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: params
      });

      if (!resp.ok) throw new Error("Failed to load filter values");
      const data = await resp.json();
      if (data.error) throw new Error(data.error.message || "Filter values error");

      const vals = (data.features || [])
        .map(f => f.attributes?.[CONFIG.filterField.name])
        .filter(v => v !== null && typeof v !== "undefined" && v !== "")
        .filter((v, i, arr) => arr.indexOf(v) === i); // unique

      // Populate dropdown
      filterSelectEl.innerHTML = "";
      const optAll = document.createElement("option");
      optAll.value = "__ALL__";
      optAll.textContent = "All values";
      filterSelectEl.appendChild(optAll);

      vals.forEach(v => {
        const opt = document.createElement("option");
        opt.value = String(v);
        opt.textContent = String(v);
        filterSelectEl.appendChild(opt);
      });

      filterFieldLabelEl.textContent = CONFIG.filterField.alias;
      statusEl.textContent = "Signed in as " + username + ". Ready to export.";
    }

    function buildWhereClause() {
      const val = filterSelectEl.value;
      if (val === "__ALL__") return "1=1";

      // Basic handling: quote strings/dates, no quotes for numbers
      const isStringLike =
        !filterFieldType || filterFieldType === "esriFieldTypeString" ||
        filterFieldType === "esriFieldTypeDate";

      if (isStringLike) {
        const safe = val.replace(/'/g, "''");
        return CONFIG.filterField.name + " = '" + safe + "'";
      } else {
        return CONFIG.filterField.name + " = " + val;
      }
    }

    async function queryFeatures(whereClause) {
      statusEl.textContent = "Querying survey data…";

      // Always include ObjectID field in outFields
      const nonAttachmentFields = allExportFields.filter(f => !f.isAttachment);
      const outFieldNames = nonAttachmentFields.map(f => f.name);
      if (!outFieldNames.includes(objectIdFieldName)) {
        outFieldNames.push(objectIdFieldName);
      }

      const url = CONFIG.featureLayerUrl + "/query";
      const params = new URLSearchParams({
        f: "json",
        where: whereClause,
        outFields: outFieldNames.join(","),
        returnGeometry: "false",
        token: accessToken,
        resultOffset: "0",
        resultRecordCount: String(CONFIG.maxRecordCountForExport)
      });

      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: params
      });

      if (!resp.ok) throw new Error("Query request failed");
      const data = await resp.json();
      if (data.error) throw new Error(data.error.message || "Query error");

      const features = data.features || [];
      statusEl.textContent = "Retrieved " + features.length + " records.";
      return features.map(f => f.attributes || {});
    }

    async function fetchAttachments(objectIds) {
      const result = {};
      if (!layerInfo.hasAttachments || !objectIds.length) return result;

      statusEl.textContent = "Fetching photo attachments…";

      const url = CONFIG.featureLayerUrl + "/queryAttachments";
      const params = new URLSearchParams({
        f: "json",
        objectIds: objectIds.join(","),
        returnUrl: "true",
        token: accessToken
      });

      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: params
      });

      if (!resp.ok) {
        console.warn("Attachments request failed");
        return result;
      }

      const data = await resp.json();
      if (data.error) {
        console.warn("Attachments error:", data.error);
        return result;
      }

      (data.attachmentGroups || []).forEach(g => {
        const pid = g.parentObjectId;
        const infos = g.attachmentInfos || [];
        result[pid] = infos.map(a => {
          // Some services return 'url', some require building it
          if (a.url) return a.url;
          const base = CONFIG.featureLayerUrl.replace(/\/0$/, "");
          return base + "/0/" + pid + "/attachments/" + a.id;
        });
      });

      return result;
    }

    // ---------- EXPORTERS ----------

    function buildExportRowsWithAttachments(rows, attachmentsMap) {
      return rows.map(row => {
        const r = { ...row };
        if (layerInfo.hasAttachments) {
          const oidVal = row[objectIdFieldName];
          const urls = attachmentsMap[oidVal] || [];
          r["_PhotoURLs"] = urls.join("; ");
        }
        return r;
      });
    }

    function exportToExcel(rowsWithAttach) {
      const sheetData = [];
      const header = allExportFields.map(f => f.alias);
      sheetData.push(header);

      rowsWithAttach.forEach(row => {
        const rowArr = allExportFields.map(f => row[f.name]);
        sheetData.push(rowArr);
      });

      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(sheetData);
      XLSX.utils.book_append_sheet(wb, ws, "SurveyExport");

      const filename = "SurveyExport_" + new Date().toISOString().slice(0,10) + ".xlsx";
      XLSX.writeFile(wb, filename);
    }

    async function exportToPdf(rowsWithAttach) {
  const { jsPDF } = window.jspdf;
  // Portrait A4-ish
  const doc = new jsPDF({ orientation: "portrait" });

  const leftMargin = 15;
  const topMargin = 15;
  const maxWidth = 180;  // usable text width
  const lineHeight = 5;

  rowsWithAttach.forEach((row, idx) => {
    // New page for every record except the first
    if (idx > 0) {
      doc.addPage();
    }

    let y = topMargin;

    // Header
    doc.setFontSize(12);
    doc.text("Survey123 Record " + (idx + 1), leftMargin, y);
    y += lineHeight + 2;

    doc.setFontSize(9);

    // 1) Normal (non-attachment) fields, only if not null/empty
    const nonAttachmentFields = allExportFields.filter(f => !f.isAttachment);
    nonAttachmentFields.forEach(field => {
      const raw = row[field.name];
      if (raw === null || typeof raw === "undefined") {
        return; // skip nulls
      }
      const valueStr = String(raw).trim();
      if (!valueStr) {
        return; // skip empty strings
      }

      const label = field.alias || field.name;
      const lineText = label + ": " + valueStr;

      // Wrap long text
      const wrapped = doc.splitTextToSize(lineText, maxWidth);
      wrapped.forEach(line => {
        if (y > 285) {
          // add a page and continue same record
          doc.addPage();
          y = topMargin;
        }
        doc.text(line, leftMargin, y);
        y += lineHeight;
      });

      // extra spacing between fields
      y += 1;
    });

    // 2) Attachment URLs, if we have the synthetic Photo URLs field
    const photoField = allExportFields.find(f => f.isAttachment);
    if (photoField) {
      const photoVal = row[photoField.name];
      if (photoVal && String(photoVal).trim()) {
        const label = photoField.alias || "Photo URLs";
        const urlsText = label + ": " + String(photoVal);

        const wrapped = doc.splitTextToSize(urlsText, maxWidth);
        wrapped.forEach(line => {
          if (y > 285) {
            doc.addPage();
            y = topMargin;
          }
          doc.text(line, leftMargin, y);
          y += lineHeight;
        });
      }
    }
  });

  const filename = "SurveyExport_" + new Date().toISOString().slice(0, 10) + ".pdf";
  doc.save(filename);
}

    // ---------- UI EVENT HANDLERS ----------

    signinBtn.addEventListener("click", () => {
      startOAuth();
    });

    exportExcelBtn.addEventListener("click", async () => {
      try {
        exportExcelBtn.disabled = true;
        exportPdfBtn.disabled = true;

        const where = buildWhereClause();
        const rows = await queryFeatures(where);
        const objectIds = rows.map(r => r[objectIdFieldName]).filter(v => v !== null && typeof v !== "undefined");
        const attachmentsMap = await fetchAttachments(objectIds);
        const rowsWithAttach = buildExportRowsWithAttachments(rows, attachmentsMap);
        exportToExcel(rowsWithAttach);
      } catch (err) {
        console.error(err);
        alert("Error exporting to Excel: " + err.message);
      } finally {
        exportExcelBtn.disabled = false;
        exportPdfBtn.disabled = false;
      }
    });

    exportPdfBtn.addEventListener("click", async () => {
      try {
        exportExcelBtn.disabled = true;
        exportPdfBtn.disabled = true;

        const where = buildWhereClause();
        const rows = await queryFeatures(where);
        const objectIds = rows.map(r => r[objectIdFieldName]).filter(v => v !== null && typeof v !== "undefined");
        const attachmentsMap = await fetchAttachments(objectIds);
        const rowsWithAttach = buildExportRowsWithAttachments(rows, attachmentsMap);
        await exportToPdf(rowsWithAttach);
      } catch (err) {
        console.error(err);
        alert("Error exporting to PDF: " + err.message);
      } finally {
        exportExcelBtn.disabled = false;
        exportPdfBtn.disabled = false;
      }
    });

    // ---------- INIT ----------

    async function init() {
      statusEl.textContent = "Checking for existing sign-in…";

      const tokenInfo = getTokenFromHash();
      if (tokenInfo) {
        accessToken = tokenInfo.token;
        username = tokenInfo.user;
      }

      if (!accessToken) {
        statusEl.textContent = "Not signed in.";
        authSection.style.display = "block";
        exportSection.style.display = "none";
        return;
      }

      try {
        const user = await getUserInfo();
        username = user.username;
        statusEl.textContent = "Signed in as " + username + ". Loading layer metadata…";

        layerInfo = await fetchLayerMetadata();
        buildFieldLists();
        await fetchFilterOptions();

        authSection.style.display = "none";
        exportSection.style.display = "block";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error initialising: " + err.message;
        authSection.style.display = "block";
        exportSection.style.display = "none";
      }
    }

    init();
  </script>
